# scope-hoisting
scope hoisting
В JavaScript, понятия scope (область видимости) и hoisting (подъем) тесно связаны с тем, как интерпретатор JavaScript управляет переменными и функциями. Давайте разберемся, что это такое и как они работают.

1. Scope (Область видимости)
Область видимости (scope) определяет, в каком контексте можно получить доступ к переменным, функциям и объектам в коде. В JavaScript существует несколько видов области видимости:

Global scope (Глобальная область видимости) — переменные, объявленные вне любых функций или блоков, доступны везде в коде.

Пример:
let globalVar = "I'm global!";

function example() {
  console.log(globalVar);  // "I'm global!" — доступна в глобальной области видимости
}

example();
console.log(globalVar);  // "I'm global!" — доступна и здесь

Function scope (Область видимости функции) — переменные, объявленные внутри функции, доступны только внутри этой функции.

Пример:
function example() {
  let functionVar = "I'm local to the function!";
  console.log(functionVar);  // Доступна внутри функции
}

example();
console.log(functionVar);  
Block scope (Область видимости блока) — это область видимости, которая появилась с введением переменных let и const в ECMAScript 6. Эти переменные существуют только в пределах блока (например, внутри цикла или условного оператора).

Пример:

javascript
Копировать код
if (true) {
  let blockVar = "I'm inside the block!";
  console.log(blockVar);  // Доступна внутри блока
}

console.log(blockVar);  

2. Hoisting (Подъем)
Hoisting — это механизм в JavaScript, при котором объявления переменных и функций "поднимаются" (hoisted) в верхнюю часть своей области видимости. Однако важно понимать, что только объявления поднимаются, а инициализация остается на месте. Это имеет важные последствия для того, как мы используем переменные и функции.

2.1 Hoisting с функциями
Объявления функций (например, с использованием function), как правило, полностью поднимаются в область видимости. То есть функция становится доступной до строки, где она была объявлена.

Пример:
console.log(greet());  // "Hello, World!"

function greet() {
  return "Hello, World!";
}

2.2 Hoisting с переменными
С переменными, объявленными через var, также происходит подъем, но они инициализируются значением undefined до того, как фактически присвоено какое-либо значение.

Пример:
console.log(myVar);  // undefined
var myVar = 10;
console.log(myVar);  // 10

В данном примере переменная myVar поднимается в верхнюю часть своей области видимости, но инициализация (присваивание значения) остаётся на месте. Поэтому на первой строке выводится undefined, а не ошибка, потому что переменная существует, но ещё не инициализирована.

2.3 Hoisting с let и const
С переменными, объявленными с использованием let и const, происходит частичный подъем, но они находятся в "временной мертвой зоне" (TDZ). Это означает, что они существуют, но нельзя использовать их до их фактического объявления в коде.

Пример:
console.log(myLetVar);  // Ошибка: Cannot access 'myLetVar' before initialization
let myLetVar = 5;

Здесь переменная myLetVar поднимется, но доступ к ней будет невозможен до её инициализации. Попытка использовать её до строки let myLetVar = 5; вызовет ошибку. То же самое касается переменных, объявленных с помощью const.

2.4 Hoisting функций-выражений
Если функция была объявлена как выражение (с использованием function в переменной), то она не будет подниматься. В этом случае подъем касается только самой переменной (которой будет присвоена функция), а не самой функции.

Пример:
console.log(foo());  // Ошибка: foo is not a function

var foo = function() {
  return "Hello, World!";
};



